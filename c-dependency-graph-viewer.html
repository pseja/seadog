<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Dependency Graph Viewer</title>
    <!-- D3.js library for data visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            font-family: sans-serif;
        }

        #container {
            display: flex;
            height: 100vh;
            box-sizing: border-box;
        }

        #left {
            width: 62%;
            background: white;
            border-right: 1px solid #ccc;
        }

        #right {
            width: 38%;
            display: flex;
            flex-direction: column;
            padding: 1em;
            box-sizing: border-box;
        }

        #graph {
            width: 100%;
            height: 100%;
        }

        #editor {
            height: 100%;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 1em;
            white-space: pre-wrap;
            overflow-y: auto;
            margin-bottom: 1em;
        }

        #controls {
            display: flex;
            gap: 1em;
            margin-top: auto;
        }

        #rescan_button,
        #folder_input {
            flex: 1;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="left">
            <svg id="graph"></svg>
        </div>
        <div id="right">
            <div id="editor" contenteditable="true"></div>
            <div id="controls">
                <input type="file" id="folder_input" webkitdirectory multiple />
                <button id="rescan_button">Rescan</button>
            </div>
        </div>
    </div>

    <script>
        const include_regex = /^\s*#include\s+["<](.+)[">]/;
        let file_map = new Map();
        let last_files = [];

        document.getElementById("folder_input").addEventListener("change", event => {
            last_files = Array.from(event.target.files);
            processFiles(last_files);
        });

        document.getElementById("rescan_button").addEventListener("click", () => {
            if (last_files.length > 0) processFiles(last_files);
        });

        async function processFiles(files) {
            file_map = new Map();
            for (const file of files) {
                if (file.name.endsWith(".c") || file.name.endsWith(".h")) {
                    const content = await file.text();
                    file_map.set(file.webkitRelativePath, content);
                }
            }

            const nodes = [];
            const links = [];
            const node_set = new Set();

            for (const [path, content] of file_map.entries()) {
                node_set.add(path);
                const lines = content.split("\n");
                for (const line of lines) {
                    const match = line.match(include_regex);
                    if (match) {
                        const included = match[1];

                        // Check if the included file exists in the file_map (this is for linking to local files, with relative paths)
                        const resolved_path = Array.from(file_map.keys()).find(filePath => filePath.endsWith(`/${included}`));
                        if (resolved_path) {
                            links.push({ source: path, target: resolved_path });
                            node_set.add(resolved_path);
                        } else {
                            // If not found, keep the included file
                            links.push({ source: path, target: included });
                            node_set.add(included);
                        }
                    }
                }
            }

            for (const id of node_set) nodes.push({ id });

            drawGraph({ nodes, links });
        }

        function drawGraph(data) {
            const svg = d3.select("#graph");
            svg.selectAll("*").remove();

            const width = svg.node().clientWidth;
            const height = svg.node().clientHeight;

            const zoom = d3.zoom()
                .scaleExtent([0.1, 5])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });

            svg.call(zoom);

            const g = svg.append("g");

            const simulation = d3.forceSimulation(data.nodes)
                .force("link", d3.forceLink(data.links).id(d => d.id).distance(120))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2));

            const link = g.append("g")
                .attr("stroke", "#aaa")
                .selectAll("line")
                .data(data.links)
                .enter().append("line")
                .attr("stroke-width", 1.5);

            const node = g.append("g")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll("circle")
                .data(data.nodes)
                .enter().append("circle")
                .attr("r", 10)
                .attr("fill", d => {
                    if (!file_map.has(d.id)) return "red";        // external lib
                    if (d.id.endsWith(".h")) return "gold";      // header file
                    if (d.id.endsWith(".c")) return "purple";    // source file
                    return "gray";
                })
                .on("click", showFile)
                .on("mouseover", showFile)
                .call(drag(simulation));

            const label = g.append("g")
                .selectAll("text")
                .data(data.nodes)
                .enter().append("text")
                .text(d => d.id)
                .attr("font-size", "10px")
                .attr("dx", 12)
                .attr("dy", 4);

            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });

            function drag(simulation) {
                return d3.drag()
                    .on("start", event => {
                        if (!event.active) simulation.alphaTarget(0.3).restart();
                        event.subject.fx = event.subject.x;
                        event.subject.fy = event.subject.y;
                    })
                    .on("drag", event => {
                        event.subject.fx = event.x;
                        event.subject.fy = event.y;
                    })
                    .on("end", event => {
                        if (!event.active) simulation.alphaTarget(0);
                        event.subject.fx = null;
                        event.subject.fy = null;
                    });
            }

            function showFile(event, d) {
                const content = file_map.get(d.id);
                document.getElementById("editor").textContent = content || "";
            }

            simulation.alpha(1).restart();
        }
    </script>
</body>

</html>